# 第八章

## 预先说明

1. 对于第八章正式提出了进程的概念，同时主要讲述了用户模块和内核之间如何进行切换，和异常控制。
2. 第八章的难点是根据函数提出了许多的新概念，概念不难理解但是多，因此需要看书从而充分理解。



## 8.1 异常

1. 异常是异常控制流的一种形式，通过硬件和操作系统实现。
2. 当处理器检测到有事件发生时，会根据异常表的跳转表，进行一个间接过程调用，从而跳转到一个专门设计的操作系统子程序。当完成后会发生如下情况:
   - 将控制返回当前指令
   - 将控制返回给下一个指令
   - 终止程序
3. 系统中每种类型的异常都分配了一个唯一的非负整数的异常符号，一部分异常数是处理器设计的，另一部分是操作系统确定的，各种异常构成了一个异常表，异常表是一组包含所有异常的地址数组，包含处理异常程序的首地址。同时对于异常表的首地址是放在一个特殊的寄存器中。
4. 异常于过程调用的不同
   - 过程调用会将返回地址压入栈，而异常的返回地址只能是当前指令或是吓一跳指令
   - 异常时处理器会把一些额外状态压入栈中，在上下文切换时会需要
   - 异常状态下的访问权限最高，如果控制转移到内核，这些会被压入内核栈中。
5. 异常分为四类
   - 中断  异步  例如读取信息时主存向cpu发信息
   - 陷阱即系统调用
   - 故障 也是类似于调用但是只在错误情况下 执行完成则返回指令否则返回abort的内核例程
   - 终止 直接将控制返回一个abort的内核例程
6. 系统调用会生成一张在内核中的跳转表，关于跳转表可以去看switch。
7. 系统调用主要是通过`syscall`的陷阱指令，同时系统调用的参数只能在寄存器



## 8.2 进程

1. 进程的两个关键抽象:
   - 逻辑控制流     逻辑流主要是说明进程之间是片段化进行的
   - 地址空间       就是说每个进程的地址都是看作相同的
2. 用户模式和内核模式  可以限制可访问的空间，通过位模式，只有设置了位模式才是内核模式
3. 上下文切换   不同进程之间切换



## 8.3 系统调用错误处理

就是我们再写代码时对于系统调用要包含一层错误提示。



## 8.4 进程控制

1. 进程的几种状态：

   - 运行-执行中或挂起等待调度
   - 停止 等待SICCONT信号
   - 终止

2. 获取进程id            pid_t可以理解为int

   ```c
   pid_t getpid(); //获取当前pid
   pid_t getppid(); //获取父进程id
   ```

3. 终止进程

   ```c
   void exit(int status);
   ```
   
4. 新建子进程

   ``` c
   pid_t fork();
   ```
   
   几个特点:
   
   - fork返回两次，父进程返回子进程id，子进程返回0
   - 并发执行，可能是子进程先执行也可能是父进程先执行
   - 相同但是独立的地址空间
   - 共享文件
   
5. 回收子进程

   ```c
   pid_t waitpid(pid_t pid, int *statusp, int options); 
   ```

   几点说明:

   - 对于默认情况下，option=0，等待直到一个子进程结束就返回。返回接受的子进程pid
   - 判定等待集合成员
     - pid>0 等待单独的子进程
     - pid=-1 所有子进程
   - 修改默认行为 option参数
     - WNOHANG       直接返回
     - WUNTRACED     一个进程终止或是被停止
     - WCONTINUED    一个运行的进程终止或是被停止的进程收到SIGCONT信号重新执行
     - 组合使用
   - 检查已回收子进程的退出状态   status是statusp指向的值
     - WIFEXITED(status)   通过exit或是return正常退出，就返回真
     - WEXITSTATUS(status)  
     - WIFSIGNALED(status) 如果子进程是因为一个未被捕获的信号终止的，就返回真
     - WTERMSIG(status)    返回导致子进程终止的信号编码
     - WIFSTOPPED(status)  当前子进程是终止的，返回真
     - WSTOPSIG(status)    返回导致子进程终止的信号编码
     - WIFCONTINUED(status) 子进程收到SIGCONT信号重新启动就返回栈
   - 如果没有子进程，则返回-1，并且error设置为ECHLED。如果被信号中断，那么他返回-1，并涉恶之error为EINTR

6. 休眠

   ```c
   unsigned int sleep(unsigned int secs);  //返回还剩下的要休眠的秒数 如果请求时间到了则返回0
   int pause();   //让函数休眠，直到收到一个信号
   ```

7. 加载

   ```c
   int execve(const char *filename, const* argv[], const* envp[]);  //加载呈贡不返回，否则返回-1
   ```

   >argv[] 参数列表列表
   >
   >envp[] 环境变量列表   



## 8.5 信号

1. 发送信号
2. 接受信号 可以自己写函数处理
3. 阻塞信号