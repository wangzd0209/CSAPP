# 第七章

## 预先说明

我个人认为理解第七章是存在一定困难的，至少在我学习的时候理解起来是有难度的，我在看书的时候是抠字眼进行理解大，因此我认为我写的笔记并不能很好的给其他人作为一个第一次阅读的指导，但是对于复习和理解一些重点内容的大意，我想我的文章还是略有帮助的，下面开始正文。

## 目录

对于之前我写的章节笔记，我是没有写目录概述的，但是我认为这个章节的内容必须写。

- 概述 
- 编译器驱动程序 主要介绍了main.c根据编译器和链接器生成可执行文件和通过加载器执行文件。
- 静态连接 这里主要是写了链接器两个重要部分，符号解析以及重定位。
- 目标文件 这里主要就是说有可重定向，可执行和共享三种目标文件
- 可重定向目标文件 主要是理解表
- 符号和符号表，两个重点，符号链接，一级符号表的struct。
  - 符号链接中有两个重点，对于全局变量的三个要求，以及使用基础命令行进行多个目标文件的链接的顺序
- 重定向 最基本的相对地址和绝对地址
- 可执行的目标文件 理解表
- 加载可执行的目标文件 理解表，这是内存的另外一个十分重要的理解层面的抽象
- 动态链接库 静态链接和动态链接的区别



## 7.1 编译器驱动程序

- .c文件通过编译器(ccl)生成.i的ASCII码的中间文件
- .i文件再通过编译器生产能一个.s的ASCII汇编语言文件(文本)       【再attack-lab中接触过】
- 再通过汇编器生成一个.o的二进制的可重定向的目标文件
- 再将多个.o文件通过链接器生成一个可执行文件，再Linux系统上是绿色的
- 如果想要执行文件输出`./绿色文件名`通过加载器，加载代码和数据复制到内存中然后转移控制到开头

## 7.2 静态链接

1. 链接器的功能:通过输入一组可重定向的目标文件和命令行参数，输出一个可加载，可执行的可执行目标文件。
2. 链接器的两个重要功能:
   - 符号解析 将符号的定义与引用链接起来。 【最简单说明:对于每一个单独的函数文件，如何加载和定义内部和外部的函数的变量】
   - 重定位  【最简单说明：对于我们的.o文件的起始地址都是00000，只有通过链接器才能将具体的地址链接。】
3. 谨记一点目标文件是一个字符序列。



## 7.3 目标文件

目标文件的三种形式:

- 可重定向
- 可执行
- 共享   【动态链接】



## 7.4 可重定位目标文件

- ELF头 一个16字节的序列以及信息 (例如:ELF头的大小，目标文件类型，机器类型，节头部表的文件偏移，节头部表中条目的大小和数量等)
- .text 已将编译的机械代码
- .rodata 只读数据
- .data 已初始化的全局变量和静态变量
- .bss 未初始化和初始化为0的全局变量和静态变量
- .symtab 符号表不包含局部变量
- .rel.text .text中需要再重定位中修改的位置
- .rel.data 被模块引用外部或是内部定义全局变量
- .debug 符号表 .line .c文件中行号和.text中机器指令之间的映射 只有再-g调用编译器驱动程序才会出现
- .strtab 一个字符串表，以null结尾的字符串序列



## 7.5 符号和符号表

1. 三种符号

   - 自身定义的并能被其他模块引用的全局符号       【对应非静态的函数和全局变量】
   - 其他模块定义并能够被引用的全局符号          【对应非静态的函数和全局变量】
   - 只能被自身定义和引用的局部符号。            【对应带static的属性和全局符号】

   即static的变量是不在栈中管理的，而是在.data和.bss中创建一个有唯一名字的本地链接符号。

2. 符号表的基本单位条目

   ```c
   typedef struct{
       int name;            //字符串表中的字节偏移
       char type:4,         //函数还是数据  4bit
            binding:4;      //本地还是全局  4bit
       char reserved;       //未使用
       short section;       //节头部表的索引
       long value;          //距离节起始位置的偏移
       long size;           //大小(字节)
   }
   ```

   section具体分配到哪个节，其中有三个伪节:

   - ABS表示不该被重定位
   
   - UNDEF表示未被定义，也就是外部引用
   
   - COMMON表示还未被分配位置的未初始化。
   
     COMMON和.bss不同
   
     - COMMON 未初始化的全局变量
     - .bss 未初始化的静态变量以及初始化为0的全局和静态变量

## 7.6 符号解析

1. 解析多重定义的全局符号规则       【已初始化符号和函数为强符号      未初始化符号未弱符号】

   - 不允许有多个同名强符号。 
   - 强符号和弱符号选强符号。
   - 多个同名弱符号，随机选。

   这里会出现至少两种错误：

   - 在函数A和函数B分别定义了一个弱符号，当选取B的为使用符号时，若A中修改了值则B中的值也会修改，会导致B的函数可能会发生错误，因为B中的x变量可能会发生变化。
   - 不同类型的同名符号可能会导致其他变量值变化，例如修改double值会修改两个int值

2. 静态库解析引用

   - 一个为维护可重定位目标文件的集合E，一个为解析的符号U, 一个在前面已经输入文件中已定义的符号集合D。
   - 片段每一个输入文件f，是目标文件还是一个存档文件(.a文件)
     - 如果是目标文件，则将f添加到E，修改U和D中的符号定义和引用
     - 如果是存档文件，则将f加入E，修改U和D中符号定义和引用，当U和D不在变化时，则将不包含在E中的成员文件(.o文件丢弃），然后处理了下一个
   - 如果U不为空则抛出错误

3. 不同的链接想法：

   - 让编译器辨认出标准函数    【类似关键字?】
   - 将所有C函数放在一个可重定向化目标代码，在每一个可执行目标文件都包含一份标准函数的集合副本
   - 构建一个存档文件，将每个函数分别变成可重定向目标文件然后作为存档文件的成员文件  【正在使用的】



## 7.7 重定位

1. 重定位的两类

   - 重定位节和符号定义，在运行时赋予函数和变量地址
   - 重定位节中的符号引用

2. 将.rel.text和.rel.data中重定向，在.rel.text和.rel.data包含一个重定向条目

   ```c
   typedef struct{
       long offet;                     //相对于节地址的索引
       long type:32,                   //重定向方法的类型
       	 symbol:32;                 //标识被修改引用应该执行的符号；
       long addend;                    //常数
   }
   ```

3. 对于具体的两种方法，细节太多因此不在这里写，详情可一看csapp书的7.7.2



## 7.8 可执行目标文件

- ELF头
- 段头部表 描述每个信息的，例如开始的地址等，.text的开头固定在 0x400000
- .init
- .text
- .rodata
- .data
- .bss
- .symtab
- .debug
- .line
- .strtab



## 7.9 加载可执行目标文件

图A



## 7.10 动态链接

1. 文件后缀.so
2. 对于每个库只有一个，是共享的
3. 通过链接器形成部分链接的可执行目标文件,然后再加载时通过动态链接器重定位.so的文本和数据到内存段，然后再在可执行目标文件中重定位所有对于.so文件中定义的符号的引用。

2. 动态链接并不是将代码和数据节复制到可执行文件，相反链接器复制了一些重定向的符号表信息，也许这就是ABS的用处；
